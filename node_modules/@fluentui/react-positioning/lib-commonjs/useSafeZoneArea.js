"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useSafeZoneArea", {
    enumerable: true,
    get: function() {
        return useSafeZoneArea;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _reactutilities = require("@fluentui/react-utilities");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _SafeZoneArea = require("./SafeZoneArea");
const _utils = require("./utils");
function useSafeZoneArea({ debug = false, disabled = false, onSafeZoneEnter, onSafeZoneMove, onSafeZoneLeave, onSafeZoneTimeout, timeout = 1500 } = {}) {
    const [stateStore] = _react.useState(_SafeZoneArea.createSafeZoneAreaStateStore);
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    const safeZoneAreaRef = _react.useRef(null);
    const containerRef = _react.useRef(null);
    const targetRef = _react.useRef(null);
    const timeoutIdRef = _react.useRef(null);
    const mouseMoveIdRef = _react.useRef(null);
    const mouseCoordinatesRef = _react.useRef({
        x: 0,
        y: 0
    });
    const containerListenerRef = _react.useMemo(()=>{
        if (disabled) {
            return ()=>{
            // do nothing
            };
        }
        let containerEl = null;
        function onContainerMouseEnter() {
            const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
            if (!targetWindow) {
                return;
            }
            if (timeoutIdRef.current) {
                targetWindow.clearTimeout(timeoutIdRef.current);
                timeoutIdRef.current = null;
            }
            stateStore.toggleActive(false);
        }
        return (el)=>{
            if (el === null) {
                containerEl === null || containerEl === void 0 ? void 0 : containerEl.removeEventListener('mouseenter', onContainerMouseEnter);
            }
            containerEl = el;
            el === null || el === void 0 ? void 0 : el.addEventListener('mouseenter', onContainerMouseEnter);
        };
    }, [
        disabled,
        stateStore,
        targetDocument
    ]);
    const targetListenerRef = _react.useMemo(()=>{
        if (disabled) {
            return ()=>{
            // do nothing
            };
        }
        let targetEl = null;
        function onTargetMouseMove(e) {
            mouseCoordinatesRef.current = {
                x: e.clientX,
                y: e.clientY
            };
            if (timeoutIdRef.current) {
                var _targetDocument_defaultView;
                targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.clearTimeout(timeoutIdRef.current);
                timeoutIdRef.current = null;
            }
            if (!stateStore.isActive()) {
                stateStore.toggleActive(true);
            }
        }
        return (el)=>{
            if (el === null) {
                const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
                if (targetWindow) {
                    if (mouseMoveIdRef.current) {
                        targetWindow.cancelAnimationFrame(mouseMoveIdRef.current);
                        mouseMoveIdRef.current = null;
                    }
                    if (timeoutIdRef.current) {
                        targetWindow.clearTimeout(timeoutIdRef.current);
                        timeoutIdRef.current = null;
                    }
                }
                targetEl === null || targetEl === void 0 ? void 0 : targetEl.removeEventListener('mousemove', onTargetMouseMove);
            }
            targetEl = el;
            el === null || el === void 0 ? void 0 : el.addEventListener('mousemove', onTargetMouseMove);
        };
    }, [
        disabled,
        stateStore,
        targetDocument
    ]);
    const onSvgMouseEnter = (0, _reactutilities.useEventCallback)((e)=>{
        onSafeZoneEnter === null || onSafeZoneEnter === void 0 ? void 0 : onSafeZoneEnter(e);
        const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
        if (!targetWindow) {
            return;
        }
        if (timeoutIdRef.current) {
            targetWindow.clearTimeout(timeoutIdRef.current);
            timeoutIdRef.current = null;
        }
        // React 17 still uses pooled synthetic events
        e.persist();
        timeoutIdRef.current = targetWindow.setTimeout(()=>{
            stateStore.toggleActive(false);
            onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 ? void 0 : onSafeZoneTimeout();
        }, timeout);
    });
    const onSvgMouseMove = (0, _reactutilities.useEventCallback)((e)=>{
        onSafeZoneMove === null || onSafeZoneMove === void 0 ? void 0 : onSafeZoneMove(e);
    });
    const onSvgMouseLeave = (0, _reactutilities.useEventCallback)((e)=>{
        onSafeZoneLeave === null || onSafeZoneLeave === void 0 ? void 0 : onSafeZoneLeave(e);
    });
    _react.useEffect(()=>{
        return stateStore.subscribe((isActive)=>{
            if (isActive) {
                function updateSVGs() {
                    const containerEl = containerRef.current;
                    const targetEl = targetRef.current;
                    const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
                    if (containerEl && targetEl) {
                        var _safeZoneAreaRef_current;
                        (_safeZoneAreaRef_current = safeZoneAreaRef.current) === null || _safeZoneAreaRef_current === void 0 ? void 0 : _safeZoneAreaRef_current.updateSVG({
                            containerPlacementSide: (0, _utils.parseFloatingUIPlacement)(containerEl.dataset.popperPlacement).side,
                            containerRect: containerEl.getBoundingClientRect(),
                            mouseCoordinates: mouseCoordinatesRef.current,
                            targetRect: targetEl.getBoundingClientRect()
                        });
                    }
                    if (targetWindow) {
                        mouseMoveIdRef.current = targetWindow.requestAnimationFrame(updateSVGs);
                    }
                }
                updateSVGs();
                return;
            }
            if (mouseMoveIdRef.current) {
                var _targetDocument_defaultView;
                targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.cancelAnimationFrame(mouseMoveIdRef.current);
                mouseMoveIdRef.current = null;
            }
        });
    }, [
        stateStore,
        targetDocument
    ]);
    return {
        containerRef: (0, _reactutilities.useMergedRefs)(containerRef, containerListenerRef),
        targetRef: (0, _reactutilities.useMergedRefs)(targetRef, targetListenerRef),
        elementToRender: _react.useMemo(()=>disabled ? null : /*#__PURE__*/ _react.createElement(_SafeZoneArea.SafeZoneArea, {
                debug: debug,
                onMouseEnter: onSvgMouseEnter,
                onMouseMove: onSvgMouseMove,
                onMouseLeave: onSvgMouseLeave,
                imperativeRef: safeZoneAreaRef,
                stateStore: stateStore
            }), [
            disabled,
            debug,
            onSvgMouseEnter,
            onSvgMouseMove,
            onSvgMouseLeave,
            stateStore
        ])
    };
}
